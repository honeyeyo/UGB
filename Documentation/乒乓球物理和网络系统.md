# ä¹’ä¹“çƒç‰©ç†å’Œç½‘ç»œç³»ç»Ÿ

## ğŸ“– æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†ä¹’ä¹“çƒ VR æ¸¸æˆä¸­çƒçš„ç‰©ç†æ¨¡æ‹Ÿå’Œç½‘ç»œåŒæ­¥æœºåˆ¶ã€‚ä¸åŸç‰ˆ UltimateGloveBall ä¸åŒï¼Œæˆ‘ä»¬çš„å®ç°ä¸“é—¨é’ˆå¯¹ä¹’ä¹“çƒè¿åŠ¨çš„ç‰¹ç‚¹è¿›è¡Œäº†ä¼˜åŒ–ï¼ŒåŒ…æ‹¬å‘çƒæƒé™æ§åˆ¶ã€éæŒæ‹æ‰‹çƒé™„ç€ä»¥åŠåŸºäº Input ç³»ç»Ÿçš„äº¤äº’è®¾è®¡ã€‚

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶å…³ç³»

```
ç©å®¶è¾“å…¥ â†’ PongInputManager â†’ çƒç”Ÿæˆè¯·æ±‚ â†’ æœåŠ¡å™¨æƒé™éªŒè¯ â†’ çƒç½‘ç»œåŒæ­¥
    â†“                                            â†“
éæŒæ‹æ‰‹æ§åˆ¶ â† çƒé™„ç€ç³»ç»Ÿ â† å‘çƒæƒé™ç®¡ç† â† æ¯”èµ›çŠ¶æ€ç®¡ç†
```

### ä¸»è¦è„šæœ¬ç»„ä»¶

**[BallNetworking.cs](../Assets/UltimateGloveBall/Scripts/Gameplay/Ball/BallNetworking.cs)**

- å¤„ç†ä¹’ä¹“çƒçš„ç½‘ç»œåŒæ­¥ã€å‘çƒæƒé™éªŒè¯
- ç®¡ç†çƒçš„ç”Ÿæˆã€é™„ç€å’Œé‡Šæ”¾é€»è¾‘
- å‘½åç©ºé—´: `PongHub.Ball`

**[BallStateSync.cs](../Assets/UltimateGloveBall/Scripts/Gameplay/Ball/BallStateSync.cs)**

- å®ç°çƒçŠ¶æ€çš„å®æ—¶åŒæ­¥
- åŒ…å«ä½ç½®ã€æ—‹è½¬ã€é€Ÿåº¦çš„å¹³æ»‘æ ¡æ­£æœºåˆ¶
- å‘½åç©ºé—´: `PongHub.Ball`

**[BallPhysics.cs](../Assets/UltimateGloveBall/Scripts/Gameplay/Ball/BallPhysics.cs)**

- æ ¸å¿ƒçƒç‰©ç†è®¡ç®—å’ŒçŠ¶æ€ç®¡ç†
- åŸºäº ITTF æ ‡å‡†çš„çœŸå®ç‰©ç†æ¨¡æ‹Ÿ
- å‘½åç©ºé—´: `PongHub.Ball`

**[BallSpawner.cs](../Assets/UltimateGloveBall/Scripts/Gameplay/Ball/BallSpawner.cs)**

- å¤„ç†çƒçš„ç”Ÿæˆå’Œé”€æ¯
- ä¸éæŒæ‹æ‰‹è¿›è¡Œä½ç½®åŒæ­¥
- å‘½åç©ºé—´: `PongHub.Ball`

## ğŸ¯ çƒç”Ÿæˆç³»ç»Ÿ

### ç”Ÿæˆè§¦å‘æœºåˆ¶

åŸºäº[Input ç³»ç»Ÿå®ç°.md](Inputç³»ç»Ÿå®ç°.md)ä¸­è®¾è®¡çš„äº¤äº’æ–¹å¼ï¼š

```csharp
// åœ¨PongInputManagerä¸­ç›‘å¬Triggerè¾“å…¥
private void HandleBallGeneration()
{
    // æ£€æŸ¥éæŒæ‹æ‰‹çš„Triggerè¾“å…¥
    bool canGenerate = ServePermissionManager.Instance.CanPlayerServe(NetworkManager.LocalClientId);

    if (GetNonPaddleHandTrigger() && canGenerate)
    {
        RequestGenerateBallServerRpc();
    }
}
```

### ç”Ÿæˆä½ç½®è®¡ç®—

```csharp
// çƒç”Ÿæˆåœ¨éæŒæ‹æ‰‹çš„æ‰‹å¿ƒä½ç½®
public Vector3 GetBallSpawnPosition()
{
    Transform nonPaddleHand = GetNonPaddleHandTransform();

    // åœ¨æ‰‹å¿ƒå‰æ–¹5cmå¤„ç”Ÿæˆçƒ
    Vector3 spawnOffset = nonPaddleHand.forward * 0.05f;
    return nonPaddleHand.position + spawnOffset;
}

public Quaternion GetBallSpawnRotation()
{
    return GetNonPaddleHandTransform().rotation;
}
```

### ç”Ÿæˆæƒé™éªŒè¯

```csharp
[ServerRpc(RequireOwnership = false)]
public void RequestGenerateBallServerRpc(ulong requesterId = 0)
{
    if (requesterId == 0) requesterId = NetworkManager.ServerRpcSender.ClientId;

    if (ServePermissionManager.Instance.CanPlayerServe(requesterId))
    {
        // ç”Ÿæˆçƒå¹¶åŒæ­¥ç»™æ‰€æœ‰å®¢æˆ·ç«¯
        SpawnBallForPlayerClientRpc(requesterId);
    }
    else
    {
        // å‘é€æƒé™æ‹’ç»æ¶ˆæ¯
        SendServePermissionDeniedClientRpc(requesterId);
    }
}
```

## ğŸ“ å‘çƒæƒé™æ§åˆ¶ç³»ç»Ÿ

### æƒé™ç®¡ç†å™¨è®¾è®¡

```csharp
public class ServePermissionManager : NetworkBehaviour
{
    [Header("æ¯”èµ›çŠ¶æ€")]
    public NetworkVariable<bool> IsInMatch = new NetworkVariable<bool>(false);
    public NetworkVariable<ulong> CurrentServerPlayerId = new NetworkVariable<ulong>();
    public NetworkVariable<int> CurrentScore = new NetworkVariable<int>(0);

    [Header("å‘çƒè§„åˆ™")]
    public int ServesPerPlayer = 2;  // æ¯äººè¿ç»­å‘çƒæ•°
    public int ServeRotationScore = 2; // æ¯å‡ åˆ†è½®æ¢å‘çƒæƒ

    // æ£€æŸ¥ç©å®¶å‘çƒæƒé™
    public bool CanPlayerServe(ulong playerId)
    {
        if (!IsInMatch.Value)
        {
            // ç»ƒä¹ æ¨¡å¼ï¼šä»»ä½•äººéƒ½å¯ä»¥å‘çƒ
            return true;
        }

        // æ¯”èµ›æ¨¡å¼ï¼šåªæœ‰å½“å‰å‘çƒæ–¹å¯ä»¥å‘çƒ
        return playerId == CurrentServerPlayerId.Value;
    }
}
```

### å‘çƒæƒè½®æ¢é€»è¾‘

```csharp
// åˆ†æ•°æ›´æ–°æ—¶æ£€æŸ¥å‘çƒæƒè½®æ¢
public void UpdateScore(int newScore)
{
    CurrentScore.Value = newScore;

    // æ¯ä¸¤åˆ†è½®æ¢ä¸€æ¬¡å‘çƒæƒ
    if (newScore > 0 && newScore % ServeRotationScore == 0)
    {
        RotateServeRight();
    }
}

public void RotateServeRight()
{
    var activePlayers = GetActivePlayers();
    if (activePlayers.Count < 2) return;

    int currentIndex = activePlayers.FindIndex(p => p.NetworkObjectId == CurrentServerPlayerId.Value);
    int nextIndex = (currentIndex + 1) % activePlayers.Count;

    CurrentServerPlayerId.Value = activePlayers[nextIndex].NetworkObjectId;

    // é€šçŸ¥æ‰€æœ‰å®¢æˆ·ç«¯å‘çƒæƒå˜æ›´
    OnServeRightChangedClientRpc(CurrentServerPlayerId.Value);
}
```

## ğŸ¤² çƒé™„ç€ç³»ç»Ÿ

### éæŒæ‹æ‰‹é™„ç€æœºåˆ¶

```csharp
public class BallAttachment : NetworkBehaviour
{
    [Header("é™„ç€è®¾ç½®")]
    public Transform attachedHand;
    public Vector3 attachOffset = Vector3.forward * 0.05f; // 5cm offset
    public bool isAttached = false;

    // é™„ç€åˆ°éæŒæ‹æ‰‹
    public void AttachToNonPaddleHand(Transform handTransform)
    {
        attachedHand = handTransform;
        isAttached = true;

        // ç¦ç”¨ç‰©ç†ï¼Œå¯ç”¨è·Ÿéš
        GetComponent<Rigidbody>().isKinematic = true;
        GetComponent<Collider>().isTrigger = true;

        // è®¾ç½®åˆå§‹ä½ç½®
        UpdateAttachedPosition();
    }

    // æ›´æ–°é™„ç€ä½ç½®
    private void UpdateAttachedPosition()
    {
        if (isAttached && attachedHand != null)
        {
            transform.position = attachedHand.position + attachedHand.TransformDirection(attachOffset);
            transform.rotation = attachedHand.rotation;
        }
    }

    // é‡Šæ”¾çƒ
    public void ReleaseBall(Vector3 releaseVelocity)
    {
        isAttached = false;
        attachedHand = null;

        // å¯ç”¨ç‰©ç†
        Rigidbody rb = GetComponent<Rigidbody>();
        rb.isKinematic = false;
        rb.velocity = releaseVelocity;

        GetComponent<Collider>().isTrigger = false;
    }
}
```

### æ‰‹éƒ¨è¯†åˆ«é€»è¾‘

```csharp
// è¯†åˆ«éæŒæ‹æ‰‹
public Transform GetNonPaddleHandTransform()
{
    // æ£€æŸ¥å“ªåªæ‰‹æŒæœ‰çƒæ‹
    bool leftHandHasPaddle = PongInputManager.Instance.IsLeftHandHoldingPaddle;

    if (leftHandHasPaddle)
    {
        // å·¦æ‰‹æŒæ‹ï¼Œè¿”å›å³æ‰‹
        return PlayerAvatar.Instance.RightHandTransform;
    }
    else
    {
        // å³æ‰‹æŒæ‹æˆ–æ— æŒæ‹ï¼Œè¿”å›å·¦æ‰‹
        return PlayerAvatar.Instance.LeftHandTransform;
    }
}

// è·å–éæŒæ‹æ‰‹çš„Triggerè¾“å…¥
private bool GetNonPaddleHandTrigger()
{
    var inputState = PongInputManager.Instance.CurrentInputState;
    bool leftHandHasPaddle = PongInputManager.Instance.IsLeftHandHoldingPaddle;

    if (leftHandHasPaddle)
    {
        // å·¦æ‰‹æŒæ‹ï¼Œæ£€æŸ¥å³æ‰‹Trigger
        return inputState.rightTrigger > 0.5f;
    }
    else
    {
        // å³æ‰‹æŒæ‹æˆ–æ— æŒæ‹ï¼Œæ£€æŸ¥å·¦æ‰‹Trigger
        return inputState.leftTrigger > 0.5f;
    }
}
```

## ğŸŒ ç½‘ç»œåŒæ­¥æœºåˆ¶

### çƒçŠ¶æ€æ•°æ®åŒ…

```csharp
public struct PongBallPacket : INetworkSerializable
{
    public uint Sequence;              // åŒ…åºåˆ—å·
    public bool IsAttached;            // æ˜¯å¦é™„ç€åˆ°æ‰‹éƒ¨
    public ulong AttachedPlayerId;     // é™„ç€çš„ç©å®¶ID
    public Vector3 Position;           // çƒä½ç½®
    public Quaternion Rotation;        // çƒæ—‹è½¬
    public bool SyncVelocity;          // æ˜¯å¦åŒæ­¥é€Ÿåº¦
    public Vector3 LinearVelocity;     // çº¿æ€§é€Ÿåº¦
    public Vector3 AngularVelocity;    // è§’é€Ÿåº¦
    public float Spin;                 // ä¹’ä¹“çƒæ—‹è½¬å€¼

    public void NetworkSerialize<T>(BufferSerializer<T> serializer) where T : IReaderWriter
    {
        serializer.SerializeValue(ref Sequence);
        serializer.SerializeValue(ref IsAttached);
        serializer.SerializeValue(ref AttachedPlayerId);
        serializer.SerializeValue(ref Position);
        serializer.SerializeValue(ref Rotation);
        serializer.SerializeValue(ref SyncVelocity);
        if (SyncVelocity)
        {
            serializer.SerializeValue(ref LinearVelocity);
            serializer.SerializeValue(ref AngularVelocity);
            serializer.SerializeValue(ref Spin);
        }
    }
}
```

### çŠ¶æ€åŒæ­¥é€»è¾‘

```csharp
public class PongBallStateSync : NetworkBehaviour
{
    private Queue<PongBallPacket> packetBuffer = new Queue<PongBallPacket>();
    private uint lastAppliedSequence = 0;

    [ServerRpc(RequireOwnership = false)]
    public void SendBallStateServerRpc(PongBallPacket packet)
    {
        // æœåŠ¡å™¨æ¥æ”¶å¹¶è½¬å‘ç»™æ‰€æœ‰å®¢æˆ·ç«¯
        ApplyBallStateClientRpc(packet);
    }

    [ClientRpc]
    public void ApplyBallStateClientRpc(PongBallPacket packet)
    {
        // é˜²æ­¢é‡å¤æˆ–ä¹±åºçš„åŒ…
        if (packet.Sequence <= lastAppliedSequence) return;

        // æ·»åŠ åˆ°ç¼“å†²åŒºå¹¶æ’åº
        packetBuffer.Enqueue(packet);
        ProcessPacketBuffer();
    }

    private void ProcessPacketBuffer()
    {
        while (packetBuffer.Count > 0)
        {
            var packet = packetBuffer.Dequeue();
            ApplyBallState(packet);
            lastAppliedSequence = packet.Sequence;
        }
    }

    private void ApplyBallState(PongBallPacket packet)
    {
        if (packet.IsAttached)
        {
            // çƒé™„ç€çŠ¶æ€
            AttachBallToPlayer(packet.AttachedPlayerId);
        }
        else
        {
            // çƒè‡ªç”±é£è¡ŒçŠ¶æ€
            ReleaseBallWithState(packet);
        }
    }
}
```

## âš½ ä¹’ä¹“çƒç‰©ç†ç‰¹æ€§

### çƒçš„ç‰©ç†å±æ€§

```csharp
[System.Serializable]
public class PongBallPhysics
{
    [Header("åŸºç¡€ç‰©ç†")]
    public float mass = 0.0027f;           // ä¹’ä¹“çƒè´¨é‡(2.7g)
    public float diameter = 0.04f;         // ç›´å¾„(40mm)
    public float bounceCoefficient = 0.9f; // åå¼¹ç³»æ•°

    [Header("ç©ºæ°”é˜»åŠ›")]
    public float airDrag = 0.1f;           // ç©ºæ°”é˜»åŠ›
    public float angularDrag = 0.05f;      // è§’é˜»åŠ›

    [Header("æ—‹è½¬æ•ˆæœ")]
    public float spinDecayRate = 0.98f;    // æ—‹è½¬è¡°å‡ç‡
    public float magnusForceMultiplier = 1.5f; // é©¬æ ¼åŠªæ–¯åŠ›ç³»æ•°

    [Header("ç¢°æ’")]
    public PhysicMaterial ballPhysicMaterial; // ç‰©ç†æè´¨
}
```

### æ—‹è½¬å’Œé©¬æ ¼åŠªæ–¯åŠ›

```csharp
public class PongBallSpin : MonoBehaviour
{
    private Rigidbody ballRigidbody;
    private Vector3 spinAxis;
    private float spinRate;

    private void FixedUpdate()
    {
        ApplyMagnusForce();
        DecaySpin();
    }

    // åº”ç”¨é©¬æ ¼åŠªæ–¯åŠ›ï¼ˆæ—‹è½¬çƒçš„åè½¬åŠ›ï¼‰
    private void ApplyMagnusForce()
    {
        if (spinRate > 0.1f)
        {
            Vector3 velocity = ballRigidbody.velocity;
            Vector3 magnusForce = Vector3.Cross(spinAxis * spinRate, velocity.normalized) *
                                 velocity.magnitude * magnusForceMultiplier;

            ballRigidbody.AddForce(magnusForce, ForceMode.Force);
        }
    }

    // æ—‹è½¬è¡°å‡
    private void DecaySpin()
    {
        spinRate *= spinDecayRate;
        if (spinRate < 0.1f) spinRate = 0f;
    }

    // æ·»åŠ æ—‹è½¬ï¼ˆå‡»çƒæ—¶è°ƒç”¨ï¼‰
    public void AddSpin(Vector3 axis, float rate)
    {
        spinAxis = axis.normalized;
        spinRate = Mathf.Max(spinRate, rate); // ä¿æŒæœ€å¤§æ—‹è½¬å€¼
    }
}
```

## ğŸ“ æ¸¸æˆæ¨¡å¼é€‚é…

### ç»ƒä¹ æ¨¡å¼

```csharp
public class PracticeMode : NetworkBehaviour
{
    public override void OnNetworkSpawn()
    {
        // ç»ƒä¹ æ¨¡å¼è®¾ç½®
        ServePermissionManager.Instance.IsInMatch.Value = false;

        // å…è®¸ä»»ä½•äººç”Ÿæˆçƒ
        // æ— å‘çƒæƒé™åˆ¶
        // æ”¯æŒå¤šçƒç»ƒä¹ 
    }

    public void EnableMultiBallMode(bool enable)
    {
        maxActiveBalls = enable ? 5 : 1;
    }
}
```

### æ¯”èµ›æ¨¡å¼

```csharp
public class MatchMode : NetworkBehaviour
{
    [Header("æ¯”èµ›è®¾ç½®")]
    public int maxScore = 11;      // å±€ç‚¹
    public int maxSets = 3;        // æœ€å¤šå±€æ•°
    public bool deuce = true;      // å¹³åˆ†å»¶é•¿

    public override void OnNetworkSpawn()
    {
        // æ¯”èµ›æ¨¡å¼è®¾ç½®
        ServePermissionManager.Instance.IsInMatch.Value = true;

        // ä¸¥æ ¼çš„å‘çƒæƒé™åˆ¶
        // å•çƒæ¨¡å¼
        // è®¡åˆ†ç³»ç»Ÿ
        InitializeMatch();
    }

    private void InitializeMatch()
    {
        // éšæœºé€‰æ‹©é¦–å‘çƒå‘˜
        var players = GetActivePlayers();
        int randomIndex = UnityEngine.Random.Range(0, players.Count);
        ServePermissionManager.Instance.CurrentServerPlayerId.Value =
            players[randomIndex].NetworkObjectId;
    }
}
```

## ğŸ› ï¸ è°ƒè¯•å’Œç›‘æ§

### çŠ¶æ€ç›‘æ§ UI

```csharp
public class BallDebugUI : MonoBehaviour
{
    [Header("UIç»„ä»¶")]
    public Text ballStatusText;
    public Text servePermissionText;
    public Text networkStatsText;

    private void Update()
    {
        UpdateBallStatus();
        UpdateServePermission();
        UpdateNetworkStats();
    }

    private void UpdateBallStatus()
    {
        var ball = FindObjectOfType<PongBallAttachment>();
        if (ball != null)
        {
            ballStatusText.text = $"çƒçŠ¶æ€: {(ball.isAttached ? "é™„ç€" : "è‡ªç”±")}\n" +
                                 $"ä½ç½®: {ball.transform.position}\n" +
                                 $"é€Ÿåº¦: {ball.GetComponent<Rigidbody>().velocity.magnitude:F2}";
        }
    }

    private void UpdateServePermission()
    {
        if (ServePermissionManager.Instance != null)
        {
            servePermissionText.text = $"å‘çƒæƒ: {ServePermissionManager.Instance.CurrentServerPlayerId.Value}\n" +
                                      $"æ¯”èµ›çŠ¶æ€: {(ServePermissionManager.Instance.IsInMatch.Value ? "æ¯”èµ›ä¸­" : "ç»ƒä¹ ")}\n" +
                                      $"å½“å‰åˆ†æ•°: {ServePermissionManager.Instance.CurrentScore.Value}";
        }
    }
}
```

### æ€§èƒ½ç›‘æ§

```csharp
public class BallNetworkProfiler : NetworkBehaviour
{
    private float lastSyncTime;
    private int packetsPerSecond;
    private Queue<float> syncIntervals = new Queue<float>();

    public void RecordSync()
    {
        float currentTime = Time.time;
        if (lastSyncTime > 0)
        {
            syncIntervals.Enqueue(currentTime - lastSyncTime);
            if (syncIntervals.Count > 60) // ä¿æŒ60ä¸ªæ ·æœ¬
            {
                syncIntervals.Dequeue();
            }
        }
        lastSyncTime = currentTime;
    }

    public float GetAverageSyncRate()
    {
        if (syncIntervals.Count == 0) return 0;
        return syncIntervals.Average();
    }
}
```

## ğŸ“‹ é›†æˆæ¸…å•

### å¿…éœ€ç»„ä»¶

1. **PongBallNetworking.cs** - æ ¸å¿ƒç½‘ç»œé€»è¾‘
2. **PongBallStateSync.cs** - çŠ¶æ€åŒæ­¥
3. **ServePermissionManager.cs** - å‘çƒæƒé™ç®¡ç†
4. **PongBallAttachment.cs** - çƒé™„ç€ç³»ç»Ÿ
5. **PongBallSpin.cs** - çƒæ—‹è½¬ç‰©ç†

### é¢„åˆ¶ä»¶è®¾ç½®

```
PongBallé¢„åˆ¶ä»¶
â”œâ”€â”€ PongBallNetworking (NetworkBehaviour)
â”œâ”€â”€ PongBallStateSync (NetworkBehaviour)
â”œâ”€â”€ PongBallAttachment
â”œâ”€â”€ PongBallSpin
â”œâ”€â”€ Rigidbody (è´¨é‡: 0.0027kg)
â”œâ”€â”€ SphereCollider (åŠå¾„: 0.02m)
â””â”€â”€ NetworkObject
```

### åœºæ™¯é…ç½®

```
GameManager
â”œâ”€â”€ ServePermissionManager (NetworkBehaviour)
â”œâ”€â”€ PongBallSpawner
â””â”€â”€ NetworkManager

Players
â”œâ”€â”€ PongInputManager
â”œâ”€â”€ PlayerAvatar
â”‚   â”œâ”€â”€ LeftHandTransform
â”‚   â””â”€â”€ RightHandTransform
â””â”€â”€ PaddleController
```

## ğŸ”„ ç‰ˆæœ¬å†å²

| ç‰ˆæœ¬     | æ›´æ–°å†…å®¹       | ä¸»è¦æ”¹è¿›       |
| -------- | -------------- | -------------- |
| **v1.0** | åŸºç¡€çƒç‰©ç†ç³»ç»Ÿ | ä»æ‰‹å¥—çƒè¿ç§»   |
| **v1.1** | éæŒæ‹æ‰‹é™„ç€   | é€‚é…ä¹’ä¹“çƒè§„åˆ™ |
| **v1.2** | å‘çƒæƒé™æ§åˆ¶   | æ¯”èµ›æ¨¡å¼æ”¯æŒ   |
| **v1.3** | æ—‹è½¬ç‰©ç†ç³»ç»Ÿ   | é©¬æ ¼åŠªæ–¯åŠ›å®ç° |
| **v1.4** | ç½‘ç»œä¼˜åŒ–       | çŠ¶æ€åŒæ­¥æ”¹è¿›   |

## ğŸ“„ ç›¸å…³æ–‡æ¡£

- [Input ç³»ç»Ÿå®ç°.md](Inputç³»ç»Ÿå®ç°.md) - è¾“å…¥ç³»ç»Ÿè®¾è®¡
- [BallPhysicsAndNetworking.md](BallPhysicsAndNetworking.md) - åŸç‰ˆå‚è€ƒå®ç°
- [Multiplayer.md](Multiplayer.md) - å¤šäººæ¸¸æˆæ¶æ„
- [Configuration.md](Configuration.md) - é¡¹ç›®é…ç½®æŒ‡å—
