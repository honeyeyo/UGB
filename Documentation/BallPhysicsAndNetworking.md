# 球物理和网络
## 实现概述

我们要完成的任务是在所有客户端上启用物理预测。这将解决诸如球体悬浮和非主机客户端上射击/投掷延迟等问题。

我们选择的方法是状态同步，Glenn Fiedler在其博客上的实现极大地启发了我们的最终代码：[状态同步](https://www.gafferongames.com/post/state_synchronization/)。

主要收获是每个客户端在本地运行Unity物理，同时与来自服务器的数据"追赶"。

## 涉及的主要脚本

**[BallNetworking.cs](../Assets/UltimateGloveBall/Scripts/Arena/Balls/BallNetworking.cs)**
- 这个网络脚本处理投掷、碰撞、所有权等。

**[BallStateSync.cs](../Assets/UltimateGloveBall/Scripts/Arena/Balls/BallStateSync.cs)**
- 这个脚本与前一个脚本配合工作。
- 它的工作是发送包含数据的数据包（如果是服务器）并应用它们（如果是客户端）。
- 该脚本包括渐进的位置、旋转和线性速度校正，以避免弹跳和抖动运动。
- 它还包含一个抖动缓冲区，以确保数据包按正确顺序应用并丢弃任何延迟的数据包。

**[BallSpawner.cs](../Assets/UltimateGloveBall/Scripts/Arena/Balls/BallSpawner.cs)**
- 这个脚本处理球的生成和死球的销毁。

**[SpawnPoint.cs](../Assets/UltimateGloveBall/Scripts/Arena/Balls/SpawnPoint.cs)**
- 这个脚本检查球是否已"占用"它，使其他球无法在那里生成。

## 球状态同步

### BallPacket

这些数据包从服务器发送并应用到所有客户端。如何应用取决于谁投掷了球。

首先，让我们看看数据包中包含什么：

**`(uint)Sequence`**
- 服务器发送数据包时服务器端的帧号。

**状态更新**

**`(bool) IsGrabbed`**
- 让客户端知道是否需要分配给手套。

**`(ulong) GrabbersNetworkObjectId`**
- 告诉客户端需要分配给哪个手套。

**`(Vector3) Position`**
- 服务器上球的位置。

**`(Quaternion) Orientation`**
- 服务器上球的旋转。

**`(bool) SyncVelocity`**
- 让客户端知道数据包中是否包含速度数据。

**`(Vector3) LinearVelocity`**
- 服务器上球的线性速度。

**`(Vector3) AngularVelocity`**
- 服务器上球的角速度。

### 为什么要将球分配给手套？

我们开始时只是在有人握住球时同步位置，但化身的更新率和平滑度与球的不匹配。然后我们尝试将游戏对象重新设为手套的父对象，但这也遇到了一些问题，因为本地位置和旋转可能有偏差。

与其迎合这些未知因素，我们决定"简单地"将球的引用给手套，手套在握住时驱动球的位置。

### 一些收获

使用Netcode的"自动父对象同步"太慢，必须由服务器控制。这给投球的玩家造成了问题。

将球附加到手套游戏对象并尝试同步手套中的本地位置给出了一些偏差的结果，可能是由于发送事件的时机和球相对于手套的位置。当我们已经有了球跟随手套的逻辑时，父子关系的建立和解除也会产生不必要的成本。

## 应用数据包

我们如何将数据包应用到客户端取决于四个因素：

### 抓取的球？

当检测到球被抓取时，我们寻找它应该父子关系的手套；然后我们：
- 将球设置到手套
- 禁用物理
- 重置本地变换

当它被释放且不再有父子关系时，我们：
- 从手套释放球
- 启用物理
- 同步位置/旋转/等等

### 球的所有者？

如果你是球的所有者，你正在握住它。我们不应用如上所述的任何额外抓取规则。

### 我投掷了球吗？

除了你之外的每个人都会将球快照到新值并应用手套释放球的规则。

### 球是静止的吗？

当球静止时，服务器不发送速度数据以减少带宽。如果球被识别为"静止"，客户端将位置、旋转等快照到零。

## 抓取球

在当前实现中，球抓取是服务器权威的，客户端将等待服务器响应以知道它们是否抓取了球。这在手套与球碰撞和球在手套中之间存在小的延迟。

这是这个演示的实现选择，以减少玩家可能认为他们抓到了球然后失去它的问题，因为服务器决定你没有球。这会招致玩家的挫败感，在多个玩家可能争夺同一个球的快节奏游戏中，这可能会变得令人困惑。

我们确实相信可以实施一些游戏机制来缓解感知问题，但需要一些调查和测试才能获得良好的结果。非常欢迎建议，请参阅我们的[贡献指南](../CONTRIBUTING.md)信息。

## 碰撞

球有不同的状态和不同的类型，这在碰撞检测方面带来了一些挑战。

生成的球不能被游戏中的球击中，所以我们需要为它们创建一个不同的物理层，并禁用游戏中的球和生成的球之间的碰撞。

然后是特殊的电球。这个球能够穿过障碍物和护盾，但也需要禁用这些元素。为此，我们为电球创建了一个特定的物理层，使其只与环境和玩家碰撞，然后我们在障碍物和护盾上创建了触发器来检测球触碰到它们但不应用物理。当球进入触发器时，它会应用函数来禁用护盾或障碍物。

## 注意去同步

由于球在被投掷后是短寿命的，我们有优势，它们的去同步非常小。我们可能会遇到我们认为球击中的东西与服务器上发生的事情之间的一些视觉差异，但大多数情况下碰撞器足够大，所以我们不需要精确的精度，游戏的速度使它减少了感知的视觉差异。
